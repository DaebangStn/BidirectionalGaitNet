#include "SurgeryExecutor.h"
#include "UriResolver.h"
#include "Log.h"
#include <iostream>
#include <fstream>
#include <algorithm>

namespace PMuscle {

SurgeryExecutor::SurgeryExecutor() 
    : mCharacter(nullptr) {
}

SurgeryExecutor::~SurgeryExecutor() {
    // Note: mCharacter is not deleted here to avoid linker issues
    // Derived classes should manage Character lifetime if they own it
}

void SurgeryExecutor::loadCharacter(const std::string& skel_path, const std::string& muscle_path,
                                   ActuatorType actuator_type) {
    // Resolve URIs
    URIResolver& resolver = URIResolver::getInstance();
    resolver.initialize();

    std::string resolved_skel = resolver.resolve(skel_path);
    std::string resolved_muscle = resolver.resolve(muscle_path);

    LOG_INFO("Loading skeleton: %s", resolved_skel.c_str());
    LOG_INFO("Loading muscle: %s", resolved_muscle.c_str());

    // Create character (without world/environment dependencies)
    mCharacter = new Character(resolved_skel, 300.0, 40.0, 5.0, true);
    mCharacter->setMuscles(resolved_muscle);
    mCharacter->setActuatorType(actuator_type);

    // Zero muscle activations
    if (mCharacter->getMuscles().size() > 0) {
        mCharacter->setActivations(mCharacter->getActivations().setZero());
    }

    LOG_INFO("Character loaded successfully");
}

void SurgeryExecutor::applyPosePreset(const std::map<std::string, Eigen::VectorXd>& joint_angles) {
    if (!mCharacter) {
        LOG_ERROR("No character loaded");
        return;
    }

    auto skeleton = mCharacter->getSkeleton();

    for (const auto& [joint_name, angles] : joint_angles) {
        auto joint = skeleton->getJoint(joint_name);
        if (!joint) {
            LOG_ERROR("Joint not found: %s", joint_name.c_str());
            continue;
        }

        if (angles.size() != joint->getNumDofs()) {
            LOG_ERROR("Joint %s expects %zu DOFs, got %zu",
                     joint_name.c_str(), joint->getNumDofs(), angles.size());
            continue;
        }

        joint->setPositions(angles);
    }

    LOG_INFO("Pose preset applied");
}

void SurgeryExecutor::resetMuscles(const std::string& muscle_xml_path) {
    if (!mCharacter) return;

    // If XML path provided, reload muscles from file (resets anchors + parameters)
    if (!muscle_xml_path.empty()) {
        LOG_INFO("[Surgery] Reloading muscles from XML: %s", muscle_xml_path.c_str());
        mCharacter->setMuscles(muscle_xml_path);
        LOG_INFO("[Surgery] Muscles reloaded from XML (anchors + parameters reset)");
        return;
    }

    // Otherwise, just reset parameters (existing behavior - anchors unchanged)
    LOG_INFO("[Surgery] Resetting muscle parameters only...");

    auto muscles = mCharacter->getMuscles();
    int resetCount = 0;
    for (auto muscle : muscles) {
        muscle->change_f(1.0);
        muscle->change_l(1.0);
        muscle->SetTendonOffset(0.0);
        resetCount++;
    }

    LOG_INFO("[Surgery] Muscle parameter reset complete. Reset %d muscles.", resetCount);
}

bool SurgeryExecutor::distributePassiveForce(const std::vector<std::string>& muscles, 
                                            const std::string& reference,
                                            const std::map<std::string, Eigen::VectorXd>& joint_angles) {
    if (!mCharacter) {
        LOG_ERROR("[Surgery] Error: No character loaded!");
        return false;
    }
    
    // Apply joint angles if specified
    if (!joint_angles.empty()) {
        applyPosePreset(joint_angles);
        LOG_INFO("[Surgery] Applied %zu joint angle(s)", joint_angles.size());
    }
    
    auto all_muscles = mCharacter->getMuscles();
    
    // Find reference muscle
    Muscle* refMuscle = nullptr;
    for (auto m : all_muscles) {
        if (m->name == reference) {
            refMuscle = m;
            break;
        }
    }
    
    if (!refMuscle) {
        LOG_ERROR("[Surgery] Error: Reference muscle '%s' not found!", reference.c_str());
        return false;
    }
    
    double refCoeff = refMuscle->lm_norm;
    int modifiedCount = 0;
    
    // Apply to all selected muscles
    for (auto m : all_muscles) {
        if (std::find(muscles.begin(), muscles.end(), m->name) != muscles.end()) {
            m->SetLmNorm(refCoeff);
            modifiedCount++;
        }
    }
    
    LOG_INFO("[Surgery] Distributed passive force coefficient %.3f from '%s' to %d muscles",
              refCoeff, reference.c_str(), modifiedCount);
    
    return true;
}

bool SurgeryExecutor::relaxPassiveForce(const std::vector<std::string>& muscles,
                                       const std::map<std::string, Eigen::VectorXd>& joint_angles) {
    if (!mCharacter) {
        LOG_ERROR("[Surgery] Error: No character loaded!");
        return false;
    }
    
    // Apply joint angles if specified
    if (!joint_angles.empty()) {
        applyPosePreset(joint_angles);
        LOG_INFO("[Surgery] Applied %zu joint angle(s)", joint_angles.size());
    }
    
    auto all_muscles = mCharacter->getMuscles();
    int relaxedCount = 0;
    
    // Apply relaxation to selected muscles
    for (auto m : all_muscles) {
        if (std::find(muscles.begin(), muscles.end(), m->name) != muscles.end()) {
            m->RelaxPassiveForce();
            relaxedCount++;
        }
    }
    
    LOG_INFO("[Surgery] Applied relaxation to %d muscles", relaxedCount);
    
    return true;
}

bool SurgeryExecutor::removeAnchorFromMuscle(const std::string& muscleName, int anchorIndex) {
    if (!mCharacter) {
        LOG_ERROR("[Surgery] Error: No character loaded!");
        return false;
    }
    
    auto muscles = mCharacter->getMuscles();
    Muscle* targetMuscle = nullptr;
    for (auto m : muscles) {
        if (m->name == muscleName) {
            targetMuscle = m;
            break;
        }
    }
    
    if (!targetMuscle) {
        LOG_ERROR("[Surgery] Error: Muscle '%s' not found!", muscleName.c_str());
        return false;
    }
    
    if (anchorIndex < 0 || anchorIndex >= targetMuscle->mAnchors.size()) {
        LOG_ERROR("[Surgery] Error: Invalid anchor index %d", anchorIndex);
        return false;
    }
    
    LOG_INFO("[Surgery] Removing anchor #%d from muscle '%s'...",
              anchorIndex, muscleName.c_str());
    
    // Remove the anchor
    delete targetMuscle->mAnchors[anchorIndex];  // Free memory
    targetMuscle->mAnchors.erase(targetMuscle->mAnchors.begin() + anchorIndex);
    
    // Recalculate muscle parameters
    targetMuscle->SetMuscle();

    LOG_INFO("[Surgery] Anchor removal complete. Muscle now has %zu anchors.",
              targetMuscle->mAnchors.size());
    
    return true;
}

bool SurgeryExecutor::copyAnchorToMuscle(const std::string& fromMuscle, int fromIndex, const std::string& toMuscle) {
    if (!mCharacter) {
        LOG_ERROR("[Surgery] Error: No character loaded!");
        return false;
    }
    
    auto muscles = mCharacter->getMuscles();
    Muscle* sourceMuscle = nullptr;
    Muscle* targetMuscle = nullptr;
    
    for (auto m : muscles) {
        if (m->name == fromMuscle) {
            sourceMuscle = m;
        }
        if (m->name == toMuscle) {
            targetMuscle = m;
        }
    }
    
    if (!sourceMuscle) {
        LOG_ERROR("[Surgery] Error: Source muscle '%s' not found!", fromMuscle.c_str());
        return false;
    }
    
    if (!targetMuscle) {
        LOG_ERROR("[Surgery] Error: Target muscle '%s' not found!", toMuscle.c_str());
        return false;
    }
    
    auto sourceAnchors = sourceMuscle->GetAnchors();
    if (fromIndex < 0 || fromIndex >= sourceAnchors.size()) {
        LOG_ERROR("[Surgery] Error: Invalid anchor index %d", fromIndex);
        return false;
    }
    
    auto sourceAnchor = sourceAnchors[fromIndex];
    
    LOG_INFO("[Surgery] Copying anchor #%d from '%s' to '%s'...",
              fromIndex, fromMuscle.c_str(), toMuscle.c_str());
    
    // Create a deep copy of the anchor
    std::vector<dart::dynamics::BodyNode*> newBodyNodes = sourceAnchor->bodynodes;
    std::vector<Eigen::Vector3d> newLocalPositions = sourceAnchor->local_positions;
    std::vector<double> newWeights = sourceAnchor->weights;
    
    Anchor* newAnchor = new Anchor(newBodyNodes, newLocalPositions, newWeights);
    
    // Add the new anchor to the target muscle
    targetMuscle->mAnchors.push_back(newAnchor);
    
    // Recalculate muscle parameters
    targetMuscle->SetMuscle();

    std::cout << "[Surgery] Anchor copied successfully. Target muscle now has "
              << targetMuscle->mAnchors.size() << " anchors." << std::endl;
    
    // Display info about the copied anchor
    if (!newBodyNodes.empty()) {
        std::cout << "[Surgery]   Copied anchor attached to: " 
                  << newBodyNodes[0]->getName() << std::endl;
        if (newBodyNodes.size() > 1) {
            std::cout << "[Surgery]   (LBS with " << newBodyNodes.size() << " body nodes)" << std::endl;
        }
    }
    
    return true;
}

bool SurgeryExecutor::editAnchorPosition(const std::string& muscle, int anchor_index, 
                                        const Eigen::Vector3d& position) {
    if (!mCharacter) {
        LOG_ERROR("[Surgery] Error: No character loaded!");
        return false;
    }
    
    auto muscles = mCharacter->getMuscles();
    Muscle* targetMuscle = nullptr;
    for (auto m : muscles) {
        if (m->name == muscle) {
            targetMuscle = m;
            break;
        }
    }
    
    if (!targetMuscle) {
        std::cerr << "[Surgery] Error: Muscle '" << muscle << "' not found!" << std::endl;
        return false;
    }
    
    auto anchors = targetMuscle->GetAnchors();
    if (anchor_index < 0 || anchor_index >= anchors.size()) {
        std::cerr << "[Surgery] Error: Invalid anchor index " << anchor_index << std::endl;
        return false;
    }
    
    auto anchor = anchors[anchor_index];
    
    // Update anchor position for ALL bodynodes in this anchor
    for (size_t i = 0; i < anchor->local_positions.size(); ++i) {
        anchor->local_positions[i] = position;
    }
    
    targetMuscle->SetMuscle();
    
    std::cout << "[Surgery] Updated position for anchor #" << anchor_index 
              << " in '" << muscle << "' to [" << position.transpose() << "]" << std::endl;
    
    return true;
}

bool SurgeryExecutor::editAnchorWeights(const std::string& muscle, int anchor_index,
                                       const std::vector<double>& weights) {
    if (!mCharacter) {
        LOG_ERROR("[Surgery] Error: No character loaded!");
        return false;
    }
    
    auto muscles = mCharacter->getMuscles();
    Muscle* targetMuscle = nullptr;
    for (auto m : muscles) {
        if (m->name == muscle) {
            targetMuscle = m;
            break;
        }
    }
    
    if (!targetMuscle) {
        std::cerr << "[Surgery] Error: Muscle '" << muscle << "' not found!" << std::endl;
        return false;
    }
    
    auto anchors = targetMuscle->GetAnchors();
    if (anchor_index < 0 || anchor_index >= anchors.size()) {
        std::cerr << "[Surgery] Error: Invalid anchor index " << anchor_index << std::endl;
        return false;
    }
    
    auto anchor = anchors[anchor_index];
    
    if (weights.size() != anchor->weights.size()) {
        std::cerr << "[Surgery] Error: Weight count mismatch. Expected " << anchor->weights.size()
                  << ", got " << weights.size() << std::endl;
        return false;
    }
    
    // Update weights in anchor
    for (size_t i = 0; i < weights.size(); ++i) {
        anchor->weights[i] = weights[i];
    }
    
    targetMuscle->SetMuscle();
    
    std::cout << "[Surgery] Updated weights for anchor #" << anchor_index 
              << " in '" << muscle << "'" << std::endl;
    
    return true;
}

bool SurgeryExecutor::addBodyNodeToAnchor(const std::string& muscle, int anchor_index,
                                         const std::string& bodynode_name, double weight) {
    if (!mCharacter) {
        LOG_ERROR("[Surgery] Error: No character loaded!");
        return false;
    }
    
    auto muscles = mCharacter->getMuscles();
    Muscle* targetMuscle = nullptr;
    for (auto m : muscles) {
        if (m->name == muscle) {
            targetMuscle = m;
            break;
        }
    }
    
    if (!targetMuscle) {
        std::cerr << "[Surgery] Error: Muscle '" << muscle << "' not found!" << std::endl;
        return false;
    }
    
    auto skel = mCharacter->getSkeleton();
    auto newBodyNode = skel->getBodyNode(bodynode_name);
    if (!newBodyNode) {
        std::cerr << "[Surgery] Error: Body node '" << bodynode_name << "' not found!" << std::endl;
        return false;
    }
    
    auto anchors = targetMuscle->GetAnchors();
    if (anchor_index < 0 || anchor_index >= anchors.size()) {
        std::cerr << "[Surgery] Error: Invalid anchor index " << anchor_index << std::endl;
        return false;
    }
    
    auto anchor = anchors[anchor_index];
    
    // Check if bodynode already exists in anchor
    for (auto bn : anchor->bodynodes) {
        if (bn == newBodyNode) {
            std::cerr << "[Surgery] Error: Body node already exists in this anchor!" << std::endl;
            return false;
        }
    }
    
    // Add new bodynode with same local position as first one
    anchor->bodynodes.push_back(newBodyNode);
    anchor->weights.push_back(weight);
    
    if (!anchor->local_positions.empty()) {
        anchor->local_positions.push_back(anchor->local_positions[0]);
    } else {
        anchor->local_positions.push_back(Eigen::Vector3d::Zero());
    }
    
    targetMuscle->SetMuscle();
    
    std::cout << "[Surgery] Added body node '" << bodynode_name << "' to anchor #" << anchor_index 
              << " in '" << muscle << "' with weight " << weight << std::endl;
    
    return true;
}

bool SurgeryExecutor::removeBodyNodeFromAnchor(const std::string& muscle, int anchor_index,
                                              int bodynode_index) {
    if (!mCharacter) {
        LOG_ERROR("[Surgery] Error: No character loaded!");
        return false;
    }
    
    auto muscles = mCharacter->getMuscles();
    Muscle* targetMuscle = nullptr;
    for (auto m : muscles) {
        if (m->name == muscle) {
            targetMuscle = m;
            break;
        }
    }
    
    if (!targetMuscle) {
        std::cerr << "[Surgery] Error: Muscle '" << muscle << "' not found!" << std::endl;
        return false;
    }
    
    auto anchors = targetMuscle->GetAnchors();
    if (anchor_index < 0 || anchor_index >= anchors.size()) {
        std::cerr << "[Surgery] Error: Invalid anchor index " << anchor_index << std::endl;
        return false;
    }
    
    auto anchor = anchors[anchor_index];
    
    if (anchor->bodynodes.size() <= 1) {
        std::cerr << "[Surgery] Error: Cannot remove last body node from anchor!" << std::endl;
        return false;
    }
    
    if (bodynode_index < 0 || bodynode_index >= anchor->bodynodes.size()) {
        std::cerr << "[Surgery] Error: Invalid body node index " << bodynode_index << std::endl;
        return false;
    }
    
    // Remove this bodynode from anchor
    std::string removed_name = anchor->bodynodes[bodynode_index]->getName();
    anchor->bodynodes.erase(anchor->bodynodes.begin() + bodynode_index);
    anchor->weights.erase(anchor->weights.begin() + bodynode_index);
    anchor->local_positions.erase(anchor->local_positions.begin() + bodynode_index);
    
    targetMuscle->SetMuscle();
    
    std::cout << "[Surgery] Removed body node '" << removed_name << "' from anchor #" 
              << anchor_index << " in '" << muscle << "'" << std::endl;
    
    return true;
}

Eigen::Isometry3d SurgeryExecutor::getBodyNodeZeroPoseTransform(dart::dynamics::BodyNode* bn) {
    Eigen::Isometry3d transform = Eigen::Isometry3d::Identity();

    // Build chain from body node to root
    std::vector<dart::dynamics::BodyNode*> chain;
    dart::dynamics::BodyNode* current = bn;
    while (current != nullptr) {
        chain.push_back(current);
        current = current->getParentBodyNode();
    }

    // Walk from root down to target body node, accumulating transforms
    // chain is in reverse order (bn -> ... -> root), so iterate backwards
    for (int i = chain.size() - 1; i >= 0; --i) {
        auto body = chain[i];
        auto joint = body->getParentJoint();

        if (joint == nullptr) continue;  // Skip root joint

        // Get joint's fixed transforms
        Eigen::Isometry3d parentTransform = joint->getTransformFromParentBodyNode();
        Eigen::Isometry3d childTransform = joint->getTransformFromChildBodyNode();

        // Get joint transform with zero DOF values (reference pose)
        Eigen::VectorXd zeroPos = Eigen::VectorXd::Zero(joint->getNumDofs());

        // Save current joint positions
        Eigen::VectorXd currentPos = joint->getPositions();

        // Temporarily set to zero to get the transform
        joint->setPositions(zeroPos);
        Eigen::Isometry3d jointTransform = joint->getRelativeTransform();

        // Restore current positions
        joint->setPositions(currentPos);

        // Accumulate transform
        transform = transform * parentTransform * jointTransform * childTransform.inverse();
    }

    return transform;
}

void SurgeryExecutor::exportMuscles(const std::string& path) {
    if (!mCharacter) {
        throw std::runtime_error("No character loaded");
    }

    auto muscles = mCharacter->getMuscles();
    if (muscles.empty()) {
        throw std::runtime_error("No muscles found in character");
    }

    std::ofstream mfs(path);
    if (!mfs.is_open()) {
        throw std::runtime_error("Failed to open file: " + path);
    }

    std::cout << "[Surgery] Saving muscle configuration to: " << path << std::endl;

    // Save current skeleton state
    auto skel = mCharacter->getSkeleton();
    Eigen::VectorXd saved_positions = skel->getPositions();

    // Move to zero pose (all joint angles = 0)
    Eigen::VectorXd zero_positions = Eigen::VectorXd::Zero(skel->getNumDofs());
    skel->setPositions(zero_positions);

    mfs << "<Muscle>" << std::endl;

    for (auto m : muscles) {
        std::string name = m->name;
        double f0 = m->f0;
        double l_m0 = m->lm_opt;
        double l_t0 = m->lt_rel;
        double pen_angle = m->pen_angle;

        mfs << "    <Unit name=\"" << name
            << "\" f0=\"" << f0
            << "\" lm=\"" << l_m0
            << "\" lt=\"" << l_t0
            << "\" pen_angle=\"" << pen_angle
            << "\">" << std::endl;

        for (auto anchor : m->GetAnchors()) {
            // Use first body node (index 0) for consistency with symmetry checking
            // The LBS system may have multiple body nodes, but for XML export we use the first
            auto body_node = anchor->bodynodes[0];
            std::string body_name = body_node->getName();

            // Get LOCAL position (pose-independent)
            Eigen::Vector3d local_position = anchor->local_positions[0];

            // Get body node's transform in zero pose (skeleton is now in zero pose)
            Eigen::Isometry3d zero_pose_transform = body_node->getWorldTransform();

            // Transform to global position in zero pose
            Eigen::Vector3d glob_position = zero_pose_transform * local_position;

            mfs << "        <Waypoint body=\"" << body_name
                << "\" p=\"" << glob_position[0] << " "
                << glob_position[1] << " "
                << glob_position[2] << " \"/>" << std::endl;
        }

        mfs << "    </Unit>" << std::endl;
    }

    mfs << "</Muscle>" << std::endl;
    mfs.close();

    // Restore original skeleton state
    skel->setPositions(saved_positions);

    std::cout << "[Surgery] Successfully saved " << muscles.size()
              << " muscles to " << path << std::endl;
}

// ═══════════════════════════════════════════════════════════════════════════
// Joint and Anchor Rotation Operations
// ═══════════════════════════════════════════════════════════════════════════

bool SurgeryExecutor::rotateJointOffset(const std::string& joint_name,
                                        const Eigen::Vector3d& axis,
                                        double angle) {
    if (!mCharacter) {
        std::cerr << "[Surgery] Error: No character loaded" << std::endl;
        return false;
    }

    auto skel = mCharacter->getSkeleton();
    auto joint = skel->getJoint(joint_name);

    if (!joint) {
        std::cerr << "[Surgery] Error: Joint '" << joint_name << "' not found" << std::endl;
        return false;
    }

    std::cout << "[Surgery] Rotating joint offset: " << joint_name << std::endl;
    std::cout << "[Surgery]   Axis: [" << axis[0] << ", " << axis[1] << ", " << axis[2] << "]" << std::endl;
    std::cout << "[Surgery]   Angle: " << angle << " rad (" << (angle * 180.0 / M_PI) << " deg)" << std::endl;

    // Get current transform from parent body frame to this joint frame
    Eigen::Isometry3d T_parent_to_joint = joint->getTransformFromParentBodyNode();

    // Create rotation transform
    Eigen::AngleAxisd rotation(angle, axis);
    Eigen::Isometry3d R = Eigen::Isometry3d::Identity();
    R.linear() = rotation.toRotationMatrix();

    // Apply rotation: new_T = R * old_T
    Eigen::Isometry3d T_new = R * T_parent_to_joint;

    // Set new transform
    joint->setTransformFromParentBodyNode(T_new);

    std::cout << "[Surgery] Joint offset rotation complete" << std::endl;

    return true;
}

bool SurgeryExecutor::rotateAnchorPoints(const std::string& muscle_name,
                                         int ref_anchor_index,
                                         const Eigen::Vector3d& search_direction,
                                         const Eigen::Vector3d& rotation_axis,
                                         double angle) {
    if (!mCharacter) {
        std::cerr << "[Surgery] Error: No character loaded" << std::endl;
        return false;
    }

    std::cout << "[Surgery] Rotating anchor points on muscle '" << muscle_name << "'" << std::endl;
    std::cout << "[Surgery]   Reference anchor index: " << ref_anchor_index << std::endl;
    std::cout << "[Surgery]   Search direction: [" << search_direction[0] << ", "
              << search_direction[1] << ", " << search_direction[2] << "]" << std::endl;
    std::cout << "[Surgery]   Rotation axis: [" << rotation_axis[0] << ", "
              << rotation_axis[1] << ", " << rotation_axis[2] << "]" << std::endl;
    std::cout << "[Surgery]   Angle: " << angle << " rad (" << (angle * 180.0 / M_PI) << " deg)" << std::endl;

    // Find reference muscle
    Muscle* ref_muscle = nullptr;
    auto muscles = mCharacter->getMuscles();
    for (auto m : muscles) {
        if (m->name == muscle_name) {
            ref_muscle = m;
            break;
        }
    }

    if (!ref_muscle) {
        std::cerr << "[Surgery] Error: Muscle '" << muscle_name << "' not found" << std::endl;
        return false;
    }

    // Validate reference anchor index
    auto ref_anchors = ref_muscle->GetAnchors();
    if (ref_anchor_index < 0 || ref_anchor_index >= ref_anchors.size()) {
        std::cerr << "[Surgery] Error: Reference anchor index " << ref_anchor_index
                  << " out of range [0, " << ref_anchors.size() << ")" << std::endl;
        return false;
    }

    auto ref_anchor = ref_anchors[ref_anchor_index];

    // Get reference anchor's primary bodynode
    if (ref_anchor->bodynodes.empty()) {
        std::cerr << "[Surgery] Error: Reference anchor has no bodynodes" << std::endl;
        return false;
    }

    auto target_bodynode = ref_anchor->bodynodes[0];
    std::cout << "[Surgery] Target bodynode: " << target_bodynode->getName() << std::endl;

    // Get reference position in world frame
    Eigen::Vector3d ref_pos = ref_anchor->GetPoint();

    // Create rotation matrix in bodynode's local frame
    Eigen::AngleAxisd rotation(angle, rotation_axis);
    Eigen::Matrix3d R_local = rotation.toRotationMatrix();

    // Get bodynode's world transform
    Eigen::Isometry3d T_world = target_bodynode->getWorldTransform();
    Eigen::Matrix3d R_world = T_world.linear();

    // Transform rotation to world frame: R_world_total = R_world * R_local * R_world^T
    Eigen::Matrix3d R_world_rotation = R_world * R_local * R_world.transpose();

    // Find all anchors on this bodynode and apply rotation
    int total_anchors_checked = 0;
    int anchors_rotated = 0;
    std::set<Muscle*> modified_muscles;

    for (auto muscle : muscles) {
        auto anchors = muscle->GetAnchors();

        for (int i = 0; i < anchors.size(); ++i) {
            auto anchor = anchors[i];

            // Check if this anchor is attached to target bodynode
            bool on_target = false;
            for (auto bn : anchor->bodynodes) {
                if (bn == target_bodynode) {
                    on_target = true;
                    break;
                }
            }

            if (!on_target) continue;

            total_anchors_checked++;

            // Get current position
            Eigen::Vector3d curr_pos = anchor->GetPoint();

            // Apply positional filter: dot(pos - ref, search_dir) > 0
            Eigen::Vector3d relative = curr_pos - ref_pos;
            double dot_product = relative.dot(search_direction);

            if (dot_product <= 0) {
                continue;  // Skip this anchor
            }

            // Apply rotation around reference point
            Eigen::Vector3d rotated = R_world_rotation * relative;
            Eigen::Vector3d new_pos = ref_pos + rotated;

            // Update anchor position (update local positions for all bodynodes)
            for (int j = 0; j < anchor->bodynodes.size(); ++j) {
                auto bn = anchor->bodynodes[j];
                Eigen::Isometry3d T_bn = bn->getWorldTransform();
                Eigen::Vector3d local_pos = T_bn.inverse() * new_pos;
                anchor->local_positions[j] = local_pos;
            }

            anchors_rotated++;
            modified_muscles.insert(muscle);
        }
    }

    // Update muscles
    for (auto muscle : modified_muscles) {
        muscle->SetMuscle();
    }

    std::cout << "[Surgery] Anchor rotation complete." << std::endl;
    std::cout << "[Surgery]   Checked " << total_anchors_checked << " anchors on target bodynode" << std::endl;
    std::cout << "[Surgery]   Rotated " << anchors_rotated << " anchors (passed positional filter)" << std::endl;
    std::cout << "[Surgery]   Updated " << modified_muscles.size() << " muscles" << std::endl;

    return anchors_rotated > 0;
}

// ═══════════════════════════════════════════════════════════════════════════
// FDO Combined Surgery (Joint + Anchor Rotation)
// ═══════════════════════════════════════════════════════════════════════════

bool SurgeryExecutor::validateAnchorReferencesBodynode(const std::string& muscle_name,
                                                        int anchor_index,
                                                        const std::string& bodynode_name) {
    if (!mCharacter) {
        std::cerr << "[Surgery] Error: No character loaded" << std::endl;
        return false;
    }

    // Find muscle
    Muscle* muscle = nullptr;
    auto muscles = mCharacter->getMuscles();
    for (auto m : muscles) {
        if (m->name == muscle_name) {
            muscle = m;
            break;
        }
    }

    if (!muscle) {
        std::cerr << "[Surgery] Error: Muscle '" << muscle_name << "' not found" << std::endl;
        return false;
    }

    // Validate anchor index
    auto anchors = muscle->GetAnchors();
    if (anchor_index < 0 || anchor_index >= anchors.size()) {
        std::cerr << "[Surgery] Error: Anchor index " << anchor_index << " out of range [0, "
                 << anchors.size() << ")" << std::endl;
        return false;
    }

    auto anchor = anchors[anchor_index];

    // Check if anchor has LBS attachment to target bodynode
    bool has_attachment = false;
    int attachment_idx = -1;
    for (int i = 0; i < anchor->bodynodes.size(); ++i) {
        if (anchor->bodynodes[i]->getName() == bodynode_name) {
            has_attachment = true;
            attachment_idx = i;
            break;
        }
    }

    if (!has_attachment) {
        // Print detailed warning with actual attachments
        std::cerr << "\n[Surgery] WARNING: Validation failed!" << std::endl;
        std::cerr << "[Surgery]   Muscle: " << muscle_name << std::endl;
        std::cerr << "[Surgery]   Anchor: #" << anchor_index << std::endl;
        std::cerr << "[Surgery]   Expected attachment to bodynode: " << bodynode_name << std::endl;
        std::cerr << "[Surgery]   Actual LBS attachments (" << anchor->bodynodes.size() << "):" << std::endl;
        for (int i = 0; i < anchor->bodynodes.size(); ++i) {
            double weight = (i < anchor->weights.size()) ? anchor->weights[i] : 0.0;
            std::cerr << "[Surgery]     [" << i << "] " << anchor->bodynodes[i]->getName()
                     << " (weight: " << weight << ")" << std::endl;
        }
        std::cerr << "[Surgery]   Operation aborted.\n" << std::endl;
        return false;
    }

    std::cout << "[Surgery] Validation passed: Anchor references target bodynode '"
             << bodynode_name << "'" << std::endl;
    return true;
}

dart::dynamics::Joint* SurgeryExecutor::getChildJoint(dart::dynamics::BodyNode* bodynode) {
    if (!bodynode) {
        return nullptr;
    }

    // Get number of child bodynodes
    size_t num_children = bodynode->getNumChildBodyNodes();

    if (num_children == 0) {
        std::cout << "[Surgery] Info: Bodynode '" << bodynode->getName()
                 << "' has no child joints" << std::endl;
        return nullptr;
    }

    if (num_children > 1) {
        std::cout << "[Surgery] Warning: Bodynode '" << bodynode->getName()
                 << "' has multiple child joints (" << num_children
                 << "), using first child" << std::endl;
    }

    // Get first child bodynode
    auto child_bn = bodynode->getChildBodyNode(0);
    if (!child_bn) {
        return nullptr;
    }

    // Get the joint connecting parent to child
    auto child_joint = child_bn->getParentJoint();

    std::cout << "[Surgery] Found child joint: '" << child_joint->getName()
             << "' (type: " << child_joint->getType() << ")" << std::endl;

    return child_joint;
}

bool SurgeryExecutor::executeFDO(const std::string& ref_muscle,
                                 int ref_anchor_index,
                                 const std::string& target_bodynode,
                                 const Eigen::Vector3d& search_direction,
                                 const Eigen::Vector3d& rotation_axis,
                                 double angle) {
    if (!mCharacter) {
        std::cerr << "[Surgery] Error: No character loaded" << std::endl;
        return false;
    }

    std::cout << "\n[Surgery] ═══════════════════════════════════════════════════" << std::endl;
    std::cout << "[Surgery] Executing FDO Combined Surgery" << std::endl;
    std::cout << "[Surgery] ═══════════════════════════════════════════════════" << std::endl;
    std::cout << "[Surgery]   Reference muscle: " << ref_muscle << std::endl;
    std::cout << "[Surgery]   Reference anchor: #" << ref_anchor_index << std::endl;
    std::cout << "[Surgery]   Target bodynode: " << target_bodynode << std::endl;
    std::cout << "[Surgery]   Rotation angle: " << (angle * 180.0 / M_PI) << " degrees" << std::endl;

    // Step 1: Validate anchor references target bodynode
    std::cout << "\n[Surgery] Step 1: Validating anchor attachment..." << std::endl;
    if (!validateAnchorReferencesBodynode(ref_muscle, ref_anchor_index, target_bodynode)) {
        return false;  // Validation prints detailed error
    }

    // Step 2: Find target bodynode
    auto skel = mCharacter->getSkeleton();
    auto target_bn = skel->getBodyNode(target_bodynode);
    if (!target_bn) {
        std::cerr << "[Surgery] Error: Target bodynode '" << target_bodynode << "' not found" << std::endl;
        return false;
    }

    // Step 3: Get child joint of target bodynode
    std::cout << "\n[Surgery] Step 2: Finding child joint of target bodynode..." << std::endl;
    auto child_joint = getChildJoint(target_bn);
    if (!child_joint) {
        std::cerr << "[Surgery] Error: No child joint found for bodynode '" << target_bodynode << "'" << std::endl;
        return false;
    }

    // Step 4: Rotate child joint
    std::cout << "\n[Surgery] Step 3: Rotating child joint..." << std::endl;
    if (!rotateJointOffset(child_joint->getName(), rotation_axis, angle)) {
        std::cerr << "[Surgery] Error: Failed to rotate child joint" << std::endl;
        return false;
    }

    // Step 5: Rotate anchors ON target bodynode (not ref anchor's bodynode)
    std::cout << "\n[Surgery] Step 4: Rotating anchors on target bodynode..." << std::endl;

    // We use the existing rotateAnchorPoints but pass the target_bodynode context
    // The function filters anchors based on positional criterion
    if (!rotateAnchorPoints(ref_muscle, ref_anchor_index, search_direction, rotation_axis, angle)) {
        std::cerr << "[Surgery] Error: Failed to rotate anchor points" << std::endl;
        return false;
    }

    std::cout << "\n[Surgery] ═══════════════════════════════════════════════════" << std::endl;
    std::cout << "[Surgery] FDO Combined Surgery Complete!" << std::endl;
    std::cout << "[Surgery] ═══════════════════════════════════════════════════\n" << std::endl;

    return true;
}

} // namespace PMuscle

