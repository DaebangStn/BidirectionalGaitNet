digraph ContractureIterativeOptimization {
    rankdir=TB;
    node [shape=box, fontname="Helvetica", fontsize=11];
    edge [fontname="Helvetica", fontsize=10];

    // Title
    labelloc="t";
    label="ContractureOptimizer: Iterative Optimization Flow";
    fontsize=14;
    fontname="Helvetica-Bold";

    // Initial capture
    subgraph cluster_init {
        label="Initialization (optimizeWithResults)";
        style=rounded;
        bgcolor="#f4f4e8";

        cache_initial [label="Cache initial lm_contract\nlm_contract_before[m] for all muscles"];
        capture_before [label="Capture BEFORE state\n(passive torques per trial)"];
        build_pose [label="buildPoseData()\nfrom ROM configs"];
    }

    // Outer Loop
    subgraph cluster_outer {
        label="Outer Iteration Loop (1..outerIterations)";
        style=rounded;
        bgcolor="#e8f4e8";

        // optimize() internals
        subgraph cluster_optimize {
            label="optimize()";
            style=rounded;
            bgcolor="#e8e8f4";

            store_base [label="Store base lm_contract\n(current values as base)"];
            ceres_solve [label="Ceres::Solve()\nMinimize torque residuals"];
            apply_pre_avg [label="Apply pre-averaging\nmuscle.lm_contract =\nbase * x[g]\n(line 803-807)"];
            biarticular_avg [label="Biarticular Averaging\nFor muscles in 2+ groups:\navg_ratio = mean(touched ratios)"];
            build_result [label="Build MuscleGroupResult\nwith averaged lm_contract_values"];
        }

        // applyResults()
        apply_results [label="applyResults()\nApply averaged values\nto muscles", style=bold];

        // Progress logging
        log_progress [label="Log progress:\n[Outer i/N] Joint=torque (target=T)"];
    }

    // Post-loop
    subgraph cluster_post {
        label="Post-Optimization";
        style=rounded;
        bgcolor="#f4e8e8";

        compute_cumulative [label="Compute cumulative ratios\ngrp.ratio = mean(final/initial)\nacross group muscles"];
        capture_after [label="Capture AFTER state\n(lm_contract, passive torques)"];
        return_result [label="Return ContractureOptResult", shape=ellipse];
    }

    // Flow connections - Initialization
    cache_initial -> capture_before;
    capture_before -> build_pose;
    build_pose -> store_base;

    // Flow connections - optimize()
    store_base -> ceres_solve;
    ceres_solve -> apply_pre_avg;
    apply_pre_avg -> biarticular_avg;
    biarticular_avg -> build_result;
    build_result -> apply_results;
    apply_results -> log_progress;

    // Loop back
    log_progress -> store_base [label="next iteration\n(sees averaged values)", style=dashed, color=blue];

    // Exit loop
    log_progress -> compute_cumulative [label="last iteration", style=bold, color=darkgreen];

    // Post-loop flow
    compute_cumulative -> capture_after;
    capture_after -> return_result;

    // Layout hints
    {rank=same; cache_initial; capture_before; build_pose;}
}
