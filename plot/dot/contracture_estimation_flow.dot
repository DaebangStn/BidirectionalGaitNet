digraph ContractureEstimationFlow {
    rankdir=TB;
    fontname="Helvetica";
    node [fontname="Helvetica", fontsize=10];
    edge [fontname="Helvetica", fontsize=9];

    // Title
    labelloc="t";
    label="Contracture Estimation Flow\nMusclePersonalizerApp::runContractureEstimation()";

    // Styling
    node [shape=box, style="rounded,filled"];

    // Color scheme
    // Entry/Exit: lightblue
    // Validation: lightyellow
    // Data loading: lightgreen
    // Optimization: lavender
    // Ceres: coral
    // Iteration: lightgray

    // =====================================================
    // ENTRY POINT (MusclePersonalizerApp)
    // =====================================================
    subgraph cluster_app {
        label="MusclePersonalizerApp::runContractureEstimation()";
        style=rounded;
        bgcolor="#F0F8FF";

        entry [
            label="runContractureEstimation()\n[Line 1675]",
            shape=ellipse,
            fillcolor="#87CEEB"
        ];

        // Validation
        check_char [label="Character\nloaded?", shape=diamond, fillcolor="#FFFACD"];
        error_char [label="ERROR:\nNo character", fillcolor="#FFB6C1"];

        // Collect selected ROM
        collect_rom [
            label="Collect selected ROM trials\nfrom mROMTrials\n(trial.selected == true)",
            fillcolor="#98FB98"
        ];

        check_rom [label="Any ROM\nselected?", shape=diamond, fillcolor="#FFFACD"];
        error_rom [label="ERROR:\nNo ROM selected", fillcolor="#FFB6C1"];

        // Load ROM configs
        load_configs [
            label="Load ROM configs\nContractureOptimizer::loadROMConfig(path)\nfor each selected path",
            fillcolor="#98FB98"
        ];

        check_configs [label="Configs\nloaded?", shape=diamond, fillcolor="#FFFACD"];
        error_configs [label="ERROR:\nNo valid configs", fillcolor="#FFB6C1"];

        // Create optimizer
        create_opt [
            label="Create ContractureOptimizer\nLoad muscle groups from\n@data/config/muscle_groups.yaml",
            fillcolor="#E6E6FA"
        ];

        check_groups [label="Groups\nloaded?", shape=diamond, fillcolor="#FFFACD"];
        error_groups [label="ERROR:\nNo muscle groups", fillcolor="#FFB6C1"];

        // Configure
        configure [
            label="Configure IterativeConfig\n- maxIterations\n- minRatio, maxRatio\n- maxOuterIterations = 3\n- convergenceThreshold = 0.01",
            fillcolor="#E6E6FA"
        ];

        // Call optimizer
        call_opt [
            label="optimizer.optimizeIterative(\n  character, configs, iterConfig)",
            fillcolor="#DDA0DD",
            style="rounded,filled,bold"
        ];

        // Convert results
        convert_results [
            label="Convert results to\nMuscleGroupResult\n(mGroupResults)",
            fillcolor="#98FB98"
        ];

        // Apply results
        apply_results [
            label="ContractureOptimizer::applyResults(\n  character, optimizerResults)",
            fillcolor="#98FB98"
        ];

        done [label="Complete", shape=ellipse, fillcolor="#90EE90"];

        // Flow
        entry -> check_char;
        check_char -> error_char [label="no"];
        check_char -> collect_rom [label="yes"];
        collect_rom -> check_rom;
        check_rom -> error_rom [label="no"];
        check_rom -> load_configs [label="yes"];
        load_configs -> check_configs;
        check_configs -> error_configs [label="no"];
        check_configs -> create_opt [label="yes"];
        create_opt -> check_groups;
        check_groups -> error_groups [label="no"];
        check_groups -> configure [label="yes"];
        configure -> call_opt;
        call_opt -> convert_results;
        convert_results -> apply_results;
        apply_results -> done;
    }

    // =====================================================
    // ITERATIVE OPTIMIZATION
    // =====================================================
    subgraph cluster_iterative {
        label="ContractureOptimizer::optimizeIterative()";
        style=rounded;
        bgcolor="#F5F5DC";

        iter_entry [
            label="optimizeIterative()\n[Line 493]",
            shape=ellipse,
            fillcolor="#87CEEB"
        ];

        find_biart [
            label="findBiarticularMuscles()\nMuscles belonging to\nmultiple groups",
            fillcolor="#98FB98"
        ];

        store_original [
            label="Store original lm_contract\nfor all muscles",
            fillcolor="#D3D3D3"
        ];

        iter_loop [
            label="For iter = 1 to maxOuterIterations",
            shape=parallelogram,
            fillcolor="#E8E8E8"
        ];

        apply_baseline [
            label="Apply current baseline\nlm_contract values\nRefreshMuscleParams()",
            fillcolor="#D3D3D3"
        ];

        call_optimize [
            label="optimize(character,\n  rom_configs, baseConfig)",
            fillcolor="#DDA0DD",
            style="rounded,filled,bold"
        ];

        avg_biart [
            label="For biarticular muscles:\navg_ratio = mean(group_ratios)\nTrack max_ratio_change",
            fillcolor="#FFFACD"
        ];

        update_baseline [
            label="Update baseline:\n- Biarticular: use avg_ratio\n- Others: use group ratio",
            fillcolor="#D3D3D3"
        ];

        check_converge [label="Converged?\nchange < 0.01", shape=diamond, fillcolor="#FFFACD"];

        update_final [
            label="Update final results\nwith averaged lm_contract\nfor biarticular muscles",
            fillcolor="#98FB98"
        ];

        apply_final [
            label="Apply final lm_contract\nRefreshMuscleParams()",
            fillcolor="#98FB98"
        ];

        iter_done [label="Return results", shape=ellipse, fillcolor="#90EE90"];

        // Flow
        iter_entry -> find_biart;
        find_biart -> store_original;
        store_original -> iter_loop;
        iter_loop -> apply_baseline;
        apply_baseline -> call_optimize;
        call_optimize -> avg_biart;
        avg_biart -> update_baseline;
        update_baseline -> check_converge;
        check_converge -> iter_loop [label="no", style=dashed];
        check_converge -> update_final [label="yes"];
        update_final -> apply_final;
        apply_final -> iter_done;
    }

    // =====================================================
    // SINGLE OPTIMIZATION (Ceres)
    // =====================================================
    subgraph cluster_optimize {
        label="ContractureOptimizer::optimize() - Ceres Solver";
        style=rounded;
        bgcolor="#FFF0F5";

        opt_entry [
            label="optimize()\n[Line 339]",
            shape=ellipse,
            fillcolor="#87CEEB"
        ];

        store_base [
            label="Store base lm_contract\nfor all muscles",
            fillcolor="#D3D3D3"
        ];

        build_pose [
            label="buildPoseData(character, rom_configs)\n\nFor each ROM config:\n- Set skeleton to ROM pose\n- Record joint angles\n- Record target torque",
            fillcolor="#98FB98"
        ];

        init_params [
            label="Initialize parameters\nx[num_groups] = 1.0\n(ratio for each muscle group)",
            fillcolor="#E6E6FA"
        ];

        build_problem [
            label="Build ceres::Problem",
            fillcolor="#FFA07A"
        ];

        add_residuals [
            label="For each pose:\nAddResidualBlock(\n  TorqueResidual,\n  HuberLoss (optional),\n  x.data())",
            fillcolor="#FFA07A"
        ];

        set_bounds [
            label="SetParameterBounds\n[minRatio, maxRatio]\nfor each group",
            fillcolor="#FFA07A"
        ];

        solver_opts [
            label="Solver Options:\n- DENSE_QR or SPARSE_NORMAL_CHOLESKY\n- function_tolerance = 1e-6\n- gradient_tolerance = 1e-8",
            fillcolor="#E6E6FA"
        ];

        ceres_solve [
            label="ceres::Solve()",
            fillcolor="#FF6347",
            style="rounded,filled,bold"
        ];

        build_results [
            label="Build MuscleGroupResult\nfor each group:\n- group_name\n- ratio = x[group_id]\n- muscle_names\n- lm_contract_values",
            fillcolor="#98FB98"
        ];

        opt_done [label="Return results", shape=ellipse, fillcolor="#90EE90"];

        // Flow
        opt_entry -> store_base;
        store_base -> build_pose;
        build_pose -> init_params;
        init_params -> build_problem;
        build_problem -> add_residuals;
        add_residuals -> set_bounds;
        set_bounds -> solver_opts;
        solver_opts -> ceres_solve;
        ceres_solve -> build_results;
        build_results -> opt_done;
    }

    // =====================================================
    // TORQUE RESIDUAL
    // =====================================================
    subgraph cluster_residual {
        label="TorqueResidual Cost Function";
        style=rounded;
        bgcolor="#FFFACD";

        residual [
            label="TorqueResidual::operator()\n\n1. Apply ratio to each muscle group:\n   lm_contract[m] = base * x[group]\n\n2. Set skeleton to ROM pose\n\n3. Compute passive torque:\n   muscle->UpdateGeometry()\n   muscle->PassiveForceTorque()\n\n4. residual = computed_torque - target_torque",
            fillcolor="#FFE4B5"
        ];
    }

    // =====================================================
    // CROSS-CLUSTER EDGES
    // =====================================================
    call_opt -> iter_entry [lhead=cluster_iterative, style=bold, color="purple"];
    call_optimize -> opt_entry [lhead=cluster_optimize, style=bold, color="red"];
    add_residuals -> residual [lhead=cluster_residual, style=dashed, color="orange"];
    iter_done -> convert_results [ltail=cluster_iterative, style=bold, color="purple"];
    opt_done -> avg_biart [ltail=cluster_optimize, style=bold, color="red"];

    // =====================================================
    // DATA STRUCTURES
    // =====================================================
    subgraph cluster_data {
        label="Key Data Structures";
        rank=sink;
        style=rounded;
        bgcolor="#F0FFF0";

        data_structs [
            label="ROMTrialConfig:\n- joint, dof_index\n- rom_angle (degrees)\n- torque (Nm)\n- muscles (affected)\n\nMuscleGroupResult:\n- group_name\n- muscle_names[]\n- ratio (optimized)\n- lm_contract_values[]\n\nMuscle Groups:\n- Loaded from muscle_groups.yaml\n- Map: group_id -> [muscle_indices]\n- Biarticular: muscles in multiple groups",
            shape=note,
            fillcolor="#F0FFF0"
        ];
    }

    // =====================================================
    // LEGEND
    // =====================================================
    subgraph cluster_legend {
        label="Legend";
        rank=sink;
        style=rounded;
        bgcolor="white";

        leg_entry [label="Entry/Exit", fillcolor="#87CEEB"];
        leg_val [label="Validation", fillcolor="#FFFACD"];
        leg_data [label="Data Loading", fillcolor="#98FB98"];
        leg_config [label="Configuration", fillcolor="#E6E6FA"];
        leg_ceres [label="Ceres Solver", fillcolor="#FFA07A"];
        leg_call [label="Function Call", fillcolor="#DDA0DD"];
        leg_iter [label="Iteration", fillcolor="#D3D3D3"];

        leg_entry -> leg_val -> leg_data -> leg_config [style=invis];
        leg_ceres -> leg_call -> leg_iter [style=invis];
    }
}
