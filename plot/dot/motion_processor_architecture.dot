// Motion Processor Architecture
// BidirectionalGaitNet Viewer - Unified Motion Processing System
// Generate: dot -Tpng -o motion_processor_architecture.png motion_processor_architecture.dot

digraph MotionProcessorArchitecture {
    rankdir=TB;
    node [shape=box, style=filled, fontname="Helvetica", fontsize=11];
    edge [fontname="Helvetica", fontsize=9];
    compound=true;
    splines=ortho;

    labelloc="t";
    label="Motion Processor Architecture";
    fontsize=14;
    fontname="Helvetica-Bold";

    // ==================== MOTION PROCESSOR ====================
    subgraph cluster_processor {
        label="MotionProcessor";
        style="rounded,filled";
        fillcolor="#E8FDE8";
        color="#5CB85C";
        penwidth=2;

        MotionProcessor [
            shape=record
            label="{MotionProcessor|
                + load(path, char, world) : Motion*\l
                + computePlayback(motion, time, phase, state, char)\l
                + evaluatePoseAtFrame(motion, frame, char, state)\l
                + getMarkersAtFrameWithOffsets(motion, frame, state)\l
                + computeCycleDistance(motion)\l
                + hasParameters(motion)\l
                + getParameterNames(motion)\l
                + getParameterValues(motion)\l
                |
                - evaluatePose()\l
                - updateMarkers()\l
                - mReader : C3D_Reader*\l
                - mParams : C3DProcessorParams\l
            }"
            fillcolor="#90EE90"
        ];
    }

    // ==================== MOTION HIERARCHY ====================
    subgraph cluster_motion {
        label="Motion Classes";
        style="rounded,filled";
        fillcolor="#E8E8FD";
        color="#5B5BDF";
        penwidth=2;

        Motion [
            shape=record
            label="{{\<\<abstract\>\>\nMotion}|
                + getRawMotionData()\l
                + getTotalTimesteps()\l
                + getValuesPerFrame()\l
                + getPose(frameIdx)\l
                + getSourceType()\l
                + hasParameters()\l
            }"
            fillcolor="#B8B8FF"
        ];

        HDF [
            shape=record
            label="{HDF|
                sourceType = \"hdf\"\l
                + parameters\l
                + timestamps\l
            }"
            fillcolor="#D0D0FF"
        ];

        C3D [
            shape=record
            label="{C3D|
                sourceType = \"c3d\"\l
                + skeletonPoses\l
                + markers\l
                + getInterpolatedMarkers()\l
            }"
            fillcolor="#D0D0FF"
        ];

        Motion -> HDF [style=dashed, arrowhead=empty];
        Motion -> C3D [style=dashed, arrowhead=empty];
    }

    // ==================== CONTEXT ====================
    subgraph cluster_context {
        label="Data Structures";
        style="rounded,filled";
        fillcolor="#FDE8E8";
        color="#D9534F";
        penwidth=2;

        MotionProcessorContext [
            shape=record
            label="{MotionProcessorContext|
                motion : Motion*\l
                state : PlaybackViewerState*\l
                character : Character*\l
                currentPose : VectorXd\l
                currentMarkers : vector\<Vector3d\>\l
                frameIndex, totalFrames\l
                hasMarkers, valid\l
            }"
            fillcolor="#FFB0B0"
        ];

        PlaybackViewerState [
            shape=record
            label="{PlaybackViewerState|
                navigationMode\l
                currentPose : VectorXd\l
                currentMarkers\l
                cycleAccumulation\l
                displayOffset\l
            }"
            fillcolor="#FFB0B0"
        ];
    }

    // ==================== UTILITIES ====================
    subgraph cluster_utils {
        label="Utilities";
        style="rounded,filled";
        fillcolor="#FFF8E8";
        color="#F0AD4E";
        penwidth=2;

        PlaybackController [
            shape=record
            label="{PlaybackController\n(static)|
                + interpolatePose()\l
                + computeCycleDistance()\l
                + determineMotionFrame()\l
                + wrapFrameFloat()\l
                + detectCycleWrap()\l
            }"
            fillcolor="#FFE0A0"
        ];

        C3D_Reader [
            shape=record
            label="{C3D_Reader|
                + loadC3D(path, params)\l
                IK conversion\l
            }"
            fillcolor="#FFE0A0"
        ];
    }

    // ==================== VIEWER ====================
    subgraph cluster_viewer {
        label="Viewer";
        style="rounded,filled";
        fillcolor="#F0F0F0";
        color="#888888";
        penwidth=2;

        GLFWApp [
            shape=record
            label="{GLFWApp|
                mMotion : Motion*\l
                mMotionState : PlaybackViewerState\l
                mMotionProcessor : unique_ptr\l
                |
                + motionPoseEval()\l
                + drawSkeleton()\l
                + drawPlayableMarkers()\l
            }"
            fillcolor="#C0C0C0"
        ];
    }

    // ==================== RELATIONSHIPS ====================
    GLFWApp -> MotionProcessor [label="owns", style=bold];
    GLFWApp -> PlaybackViewerState [label="owns"];
    GLFWApp -> Motion [label="uses"];

    MotionProcessor -> Motion [label="processes", style=dashed];
    MotionProcessor -> MotionProcessorContext [label="produces"];
    MotionProcessor -> PlaybackViewerState [label="updates"];
    MotionProcessor -> PlaybackController [label="uses"];
    MotionProcessor -> C3D_Reader [label="uses\n(for C3D)"];

    C3D_Reader -> C3D [label="creates"];
}
